package org.shadow.click_and_crypt;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.stage.Stage;
import org.jetbrains.annotations.Nullable;
import org.shadow.lib.exception.FatalRuntimeException;
import org.shadow.click_and_crypt.exception.RecoverableErrorCause;
import org.shadow.click_and_crypt.exception.RecoverableRuntimeException;
import org.shadow.lib.gui.ModernYesNo;
import org.shadow.click_and_crypt.form.encrypt_decrypt.EncryptDecrypt;
import org.shadow.lib.gui.ModernAlert;

import java.util.Arrays;

// How is the application initialized ?
//
// 1. the configuration is asynchronously loaded (`Platform.runLater(...)`) from the command line.
//    Loaded parameters are:
//        * the action to be executed: encryption or decryption.
//        * the path to the input file for encryption or decryption.
//        * the path to the output file generated by the encryption or decryption.
//    This operation checks that the requested action is valid. It should be "encrypt" or "decrypt".
//    However, it does not check the properties of the input and output files.
//    See `RunSetConfiguration`
//
// 2. the configuration is asynchronously verified (`Platform.runLater(...)`). Verified parameters are:
//        * the input file for encryption or decryption.
//        * the output file generated by the encryption or decryption.
//    See `RunVerifyConfiguration`
//
// `Main.start`:              `Platform.runLater(runSetConfiguration)` - code marker "M:001"
// `RunSetConfiguration.run`: `Platform.runLater(runVerifyConfiguration)` - code marker "M:002"
//
// Why do we process it this way ? Why not perform the loading and complete configuration verification
// in a single pass ?
//
// Because the input and output file paths must be configured when the main form is created, even if the files cannot
// be processed. If an exception is thrown during the loading of the configuration, then the latter is not set.

public class Main extends Application {

    private static Configuration configuration;
    private static final boolean isVerbose = false;
    RunSetConfiguration runSetConfiguration;
    private static EncryptDecrypt encryptDecryptForm;

    @Override
    public void start(Stage stage) {
        // WARNING: do not prevent this function to terminate. Do not throw exceptions in this function.

        // Get the paths to the resources (that are embedded within the application JAR file).
        final String modernAlertCssPath = getClass().getResource("/css/modern-alert.css").toExternalForm();
        final String modernYesNoCssPath = getClass().getResource("/css/modern-yes-no.css").toExternalForm();
        final String appCssPath = getClass().getResource("/css/app.css").toExternalForm();
        final String modernSuccessCssPath = getClass().getResource("/css/modern-success.css").toExternalForm();
        final String icon16x16 = getClass().getResource("/icons/app16x16.png").toExternalForm();

        // Build the interface.
        stage.setTitle("cryptos");
        encryptDecryptForm = new EncryptDecrypt();
        Image icon = new Image(icon16x16);
        stage.getIcons().add(icon);
        Scene scene = new Scene(encryptDecryptForm);
        scene.getStylesheets().add(appCssPath);
        stage.setScene(scene);

        // The code below sets a global handler whose role is to catch any exceptions that are not previously
        // caught. Please note that these exceptions are associated with fatal (unrecoverable) errors.
        Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
            handleException(throwable);
        });

        // The code below sets a handler that is executed as soon as the application has been launched and
        // the event loop has started. Please note that no exception should be raised while the application
        // has not been launched and the event loop has not been started. This is why we load the configuration
        // from the command line "later" (that is: after the application has been launched and the event loop been
        // started).
        configuration = new Configuration();
        configuration.setModernAlertCssPath(modernAlertCssPath);
        configuration.setModernYesNoCssPath(modernYesNoCssPath);
        configuration.setModernSuccessCssPath(modernSuccessCssPath);
        configuration.setVerbose(isVerbose);
        runSetConfiguration = new RunSetConfiguration(configuration, getParameters().getRaw(), encryptDecryptForm);
        Platform.runLater(runSetConfiguration); // [M:001] load the configuration from the command line later

        stage.show();
    }

    /**
     * Handles exceptions by printing the stack trace if in verbose mode,
     * displaying an alert to the user, and terminating the application.
     *
     * @param throwable The throwable object representing the exception to be handled.
     */

    private static void handleException(Throwable throwable) {
        if (configuration.isVerbose()) throwable.printStackTrace();

        Platform.runLater(() -> {
            if (throwable instanceof FatalRuntimeException) {
                encryptDecryptForm.setVisible(false);
                ModernAlert alert;
                @Nullable String details = ((FatalRuntimeException) throwable).getDetails();
                if (null == details) {
                    alert = new ModernAlert(throwable.getMessage());
                } else {
                    alert = new ModernAlert(throwable.getMessage(), details);
                }
                alert.getScene().getStylesheets().add(configuration.getModernAlertCssPath());
                alert.showAndWait();
                System.exit(1);
            } else if (throwable instanceof RecoverableRuntimeException) {
//                @Nullable String details = ((RecoverableRuntimeException) throwable).getDetails();
                RecoverableErrorCause cause = ((RecoverableRuntimeException) throwable).getErrorCause();
                switch (cause) {
                    case OUTPUT_FILE_EXISTS: {
                        ModernYesNo yesNo = new ModernYesNo("The destination file already exists.\nOverride it?");
                        yesNo.getScene().getStylesheets().add(configuration.getModernYesNoCssPath());
                        yesNo.showAndWait();
                        if (!yesNo.isYes()) System.exit(0);
                        return;
                    }
                }
            }

            // The code below should not be executed.
            encryptDecryptForm.setVisible(false);
            ModernAlert alert = new ModernAlert("An unexpected error occurred. Please report this error.", Arrays.toString(throwable.getStackTrace()));
            alert.getScene().getStylesheets().add(configuration.getModernAlertCssPath());
            alert.showAndWait();
            System.exit(1);
        });
    }

    public static void main(String[] args) {
        launch(args);
    }
}